import type { Translation } from "../translation-keys.ts";

export const de: Translation = {
  collapse: "Einklappen",
  expand: "Ausklappen",

  fieldDescriptionPlaceholder: "Zweck dieses Felds beschreiben",
  fieldDelete: "Feld l√∂schen",
  fieldDescription: "Beschreibung",
  fieldDescriptionTooltip: "Kontext zur Bedeutung dieses Felds hinzuf√ºgen",
  fieldNameLabel: "Feldname",
  fieldNamePlaceholder: "z.B. firstName, age, isActive",
  fieldNameTooltip:
    "CamelCase f√ºr bessere Lesbarkeit verwenden (z.B. firstName)",
  fieldRequiredLabel: "Pflichtfeld",
  fieldType: "Feldart",
  fieldTypeExample: "Beispiel:",
  fieldTypeTooltipString: "string: Text",
  fieldTypeTooltipNumber: "number: Zahl",
  fieldTypeTooltipBoolean: "boolean: Wahr/Falsch",
  fieldTypeTooltipObject: "object: Verschachteltes JSON",
  fieldTypeTooltipArray: "array: Liste von Werten",
  fieldAddNewButton: "Feld hinzuf√ºgen",
  fieldAddNewBadge: "Schema-Builder",
  fieldAddNewCancel: "Abbrechen",
  fieldAddNewConfirm: "Feld hinzuf√ºgen",
  fieldAddNewDescription: "Neues Feld f√ºr das JSON-Schema erstellen",
  fieldAddNewLabel: "Neues Feld hinzuf√ºgen",

  fieldTypeTextLabel: "Text",
  fieldTypeTextDescription: "F√ºr Textwerte wie Namen, Beschreibungen usw.",
  fieldTypeNumberLabel: "Zahl",
  fieldTypeNumberDescription: "F√ºr Dezimal- oder Ganzzahlen",
  fieldTypeBooleanLabel: "Ja/Nein",
  fieldTypeBooleanDescription: "F√ºr Wahr/Falsch-Werte",
  fieldTypeObjectLabel: "Gruppe",
  fieldTypeObjectDescription: "Zum Gruppieren verwandter Felder",
  fieldTypeArrayLabel: "Liste",
  fieldTypeArrayDescription: "F√ºr Sammlungen von Elementen",

  propertyDescriptionPlaceholder: "Beschreibung hinzuf√ºgen...",
  propertyDescriptionButton: "Beschreibung hinzuf√ºgen...",
  propertyRequired: "Erforderlich",
  propertyOptional: "Optional",
  propertyDelete: "Feld l√∂schen",

  schemaEditorTitle: "JSON-Schema-Editor",
  schemaEditorToggleFullscreen: "Vollbild umschalten",
  schemaEditorEditModeVisual: "Visuell",
  schemaEditorEditModeJson: "JSON",

  arrayMinimumLabel: "Mindestanzahl an Elementen",
  arrayMinimumPlaceholder: "Kein Minimum",
  arrayMaximumLabel: "Maximale Anzahl an Elemente",
  arrayMaximumPlaceholder: "Kein Maximum",
  arrayForceUniqueItemsLabel: "Nur eindeutige Elemente erlauben",
  arrayItemTypeLabel: "Elementtyp",
  arrayValidationErrorMinMax:
    "'minItems' darf nicht gr√∂√üer als 'maxItems' sein.",
  arrayValidationErrorContainsMinMax:
    "'minContains' darf nicht gr√∂√üer als 'maxContains' sein.",

  booleanAllowFalseLabel: "Falsch-Werte erlauben",
  booleanAllowTrueLabel: "Wahr-Werte erlauben",
  booleanNeitherWarning:
    "Achtung: Mindestens einer von beiden Werten muss erlaubt sein.",

  numberMinimumLabel: "Minimalwert",
  numberMinimumPlaceholder: "Kein Minimum",
  numberMaximumLabel: "Maximalwert",
  numberMaximumPlaceholder: "Kein Maximum",
  numberExclusiveMinimumLabel: "Exklusives Minimum",
  numberExclusiveMinimumPlaceholder: "Kein exklusives Minimum",
  numberExclusiveMaximumLabel: "Exklusives Maximum",
  numberExclusiveMaximumPlaceholder: "Kein exklusives Maximum",
  numberMultipleOfLabel: "Vielfaches von",
  numberMultipleOfPlaceholder: "Beliebig",
  numberAllowedValuesEnumLabel: "Erlaubte Werte (Enum)",
  numberAllowedValuesEnumNone: "Keine Einschr√§nkung f√ºr Werte festgelegt",
  numberAllowedValuesEnumAddLabel: "Hinzuf√ºgen",
  numberAllowedValuesEnumAddPlaceholder: "Erlaubten Wert hinzuf√ºgen...",
  numberValidationErrorMinMax: "Minimum und Maximum m√ºssen konsistent sein.",
  numberValidationErrorBothExclusiveAndInclusiveMin:
    "Sowohl 'exclusiveMinimum' als auch 'minimum' d√ºrfen nicht gleichzeitig festgelegt werden.",
  numberValidationErrorBothExclusiveAndInclusiveMax:
    "Sowohl 'exclusiveMaximum' als auch 'maximum' d√ºrfen nicht gleichzeitig festgelegt werden.",
  numberValidationErrorEnumOutOfRange:
    "Enum-Werte m√ºssen innerhalb des definierten Bereichs liegen.",

  objectPropertiesNone: "Keine Eigenschaften definiert",
  objectValidationErrorMinMax:
    "'minProperties' darf nicht gr√∂√üer als 'maxProperties' sein.",

  stringMinimumLengthLabel: "Minimale L√§nge",
  stringMinimumLengthPlaceholder: "Kein Minimum",
  stringMaximumLengthLabel: "Maximale L√§nge",
  stringMaximumLengthPlaceholder: "Kein Maximum",
  stringPatternLabel: "Muster (Regex)",
  stringPatternPlaceholder: "^[a-zA-Z]+$",
  stringFormatLabel: "Format",
  stringFormatNone: "Keins",
  stringFormatDateTime: "Datum und Uhrzeit",
  stringFormatDate: "Datum",
  stringFormatTime: "Uhrzeit",
  stringFormatEmail: "E-Mail",
  stringFormatUri: "URI",
  stringFormatUuid: "UUID",
  stringFormatHostname: "Hostname",
  stringFormatIpv4: "IPv4-Adresse",
  stringFormatIpv6: "IPv6-Adresse",
  stringAllowedValuesEnumLabel: "Erlaubte Werte (Enum)",
  stringAllowedValuesEnumNone: "Keine Einschr√§nkung f√ºr Werte festgelegt",
  stringAllowedValuesEnumAddPlaceholder: "Erlaubten Wert hinzuf√ºgen...",
  stringValidationErrorLengthRange:
    "'Minimale L√§nge' darf nicht gr√∂√üer als 'Maximale L√§nge' sein.",

  schemaTypeArray: "Liste",
  schemaTypeBoolean: "Ja/Nein",
  schemaTypeNumber: "Zahl",
  schemaTypeObject: "Objekt",
  schemaTypeString: "Text",
  schemaTypeNull: "Leer",

  inferrerTitle: "JSON-Schema ableiten",
  inferrerDescription:
    "JSON-Dokument unten einf√ºgen, um ein Schema daraus zu erstellen.",
  inferrerCancel: "Abbrechen",
  inferrerGenerate: "Schema erstellen",
  inferrerErrorInvalidJson: "Ung√ºltiges JSON-Format. Bitte Eingabe pr√ºfen.",

  validatorTitle: "JSON validieren",
  validatorDescription:
    "JSON-Dokument einf√ºgen, um es gegen das aktuelle Schema zu pr√ºfen. Die Validierung erfolgt automatisch beim Tippen.",
  validatorCurrentSchema: "Aktuelles Schema:",
  validatorContent: "Zu pr√ºfendes JSON:",
  validatorValid: "JSON ist g√ºltig zum Schema!",
  validatorErrorInvalidSyntax: "Ung√ºltige JSON-Syntax",
  validatorErrorSchemaValidation: "Schema-Validierungsfehler",
  validatorErrorCount: "{count} Validierungsfehler gefunden",
  validatorErrorPathRoot: "Wurzel",
  validatorErrorLocationLineAndColumn: "Zeile {line}, Spalte {column}",
  validatorErrorLocationLineOnly: "Zeile {line}",

  visualizerDownloadTitle: "Schema herunterladen",
  visualizerDownloadFileName: "schema.json",
  visualizerSource: "JSON-Schema-Quelle",

  visualEditorNoFieldsHint1: "Noch keine Felder definiert",
  visualEditorNoFieldsHint2: "Erstes Feld hinzuf√ºgen, um zu starten",

  typeValidationErrorNegativeLength: "L√§ngenwerte d√ºrfen nicht negativ sein.",
  typeValidationErrorIntValue: "Der Wert muss eine ganze Zahl sein.",
  typeValidationErrorPositive: "Der Wert muss positiv sein.",

  // Advanced Keywords - Conditional Schema
  conditionalTitle: "Bedingte Validierung (if/then/else)",
  conditionalRemoveAll: "Alle entfernen",
  conditionalIfLabel: "IF (Bedingung)",
  conditionalAddIf: "IF-Bedingung hinzuf√ºgen",
  conditionalIfHint: "Wenn dieses Schema √ºbereinstimmt, THEN-Schema anwenden",
  conditionalThenLabel: "THEN (Anwenden wenn IF √ºbereinstimmt)",
  conditionalAddThen: "THEN-Schema hinzuf√ºgen",
  conditionalThenHint: "Dieses Schema wird angewendet, wenn die IF-Bedingung √ºbereinstimmt",
  conditionalElseLabel: "ELSE (Anwenden wenn IF nicht √ºbereinstimmt)",
  conditionalAddElse: "ELSE-Schema hinzuf√ºgen",
  conditionalElseHint: "Dieses Schema wird angewendet, wenn die IF-Bedingung nicht √ºbereinstimmt",
  conditionalNoCondition: "Keine bedingte Validierung definiert",
  conditionalNoConditionHint: "F√ºgen Sie eine IF-Bedingung hinzu, um bedingte Schema-Validierung zu aktivieren",

  // Advanced Keywords - Prefix Items
  prefixItemsTitle: "Tupel-Validierung (prefixItems)",
  prefixItemsDescription: "Definieren Sie Schemas f√ºr jede Position im Array",
  prefixItemsAddPosition: "Position hinzuf√ºgen",
  prefixItemsPositionLabel: "Position {index} Schema",
  prefixItemsNoPositions: "Keine Tupel-Positionen definiert",
  prefixItemsNoPositionsHint: "Positionen hinzuf√ºgen, um ein Tupel mit festem Schema f√ºr jede Position zu definieren",
  prefixItemsAllowAdditional: "Zus√§tzliche Elemente erlauben",
  prefixItemsAllowAdditionalHint: "Steuern, ob Elemente √ºber definierte Positionen hinaus erlaubt sind",
  prefixItemsAdditionalSchema: "Schema f√ºr zus√§tzliche Elemente",
  prefixItemsAdditionalSchemaHint: "Schema f√ºr Elemente √ºber Position {count} hinaus",
  prefixItemsTip: "üí° Tipp: prefixItems ersetzt die Array-Form von items aus Draft-07 f√ºr Tupel-Validierung",

  // Advanced Keywords - Dynamic References
  dynamicRefsTitle: "Dynamische Referenzen",
  dynamicRefsDescription: "Erweiterte Schema-Komposition mit dynamischen Ankern und Referenzen",
  dynamicAnchorLabel: "Dynamischer Anker ($dynamicAnchor)",
  dynamicAnchorPlaceholder: "z.B. node oder #meta",
  dynamicAnchorHint: "Definieren Sie einen dynamischen Anker, der √ºber Schemas referenziert werden kann. Verwenden Sie dies, um Erweiterungspunkte in Ihrem Schema zu erstellen, die in abgeleiteten Schemas √ºberschrieben werden k√∂nnen.",
  dynamicRefLabel: "Dynamische Referenz ($dynamicRef)",
  dynamicRefPlaceholder: "z.B. #node oder https://example.com/schema#meta",
  dynamicRefHint: "Referenzieren Sie einen dynamischen Anker, der in diesem oder einem anderen Schema definiert ist. Die Referenz wird w√§hrend der Validierung dynamisch aufgel√∂st.",
  dynamicRefsInfoTitle: "üí° Was sind dynamische Referenzen?",
  dynamicRefsInfoDescription: "Dynamische Referenzen ($dynamicRef und $dynamicAnchor) erm√∂glichen es Schemas, Ankerpunkte zu referenzieren, die in erweiternden Schemas √ºberschrieben werden k√∂nnen. Dies erm√∂glicht erweiterte Kompositionsmuster wie rekursive Schemas mit Erweiterungspunkten.",
  dynamicRefsInfoExample: "Beispiel: Eine Baumstruktur, bei der jeder Knoten mit benutzerdefinierten Eigenschaften erweitert werden kann, w√§hrend die Grundstruktur beibehalten wird.",
  dynamicRefsMigrationNote: "üìù Hinweis: $dynamicRef und $dynamicAnchor ersetzen $recursiveRef und $recursiveAnchor aus Draft 2019-09",

  // Advanced Keywords - Dependent Schemas
  dependentSchemasTitle: "Abh√§ngige Schemas",
  dependentSchemasDescription: "Definieren Sie Schemas, die angewendet werden, wenn bestimmte Eigenschaften vorhanden sind",
  dependentSchemasWhenPresent: "Wenn {property} vorhanden ist:",
  dependentSchemasAppliesWhen: "Dieses Schema wird angewendet, wenn die Eigenschaft \"{property}\" im Objekt vorhanden ist",
  dependentSchemasNone: "Keine abh√§ngigen Schemas definiert",
  dependentSchemasNoneHint: "F√ºgen Sie abh√§ngige Schemas hinzu, um zus√§tzliche Validierung anzuwenden, wenn bestimmte Eigenschaften vorhanden sind",
  dependentSchemasAddLabel: "Abh√§ngiges Schema hinzuf√ºgen",
  dependentSchemasPropertyPlaceholder: "Eigenschaftsname (z.B. credit_card)",
  dependentSchemasPropertyHint: "Geben Sie den Eigenschaftsnamen ein, dessen Vorhandensein zus√§tzliche Validierung ausl√∂st",
  dependentSchemasExampleTitle: "üí° Beispiel-Anwendungsfall",
  dependentSchemasExampleText: "Wenn credit_card vorhanden ist, erfordere billing_address und cvv Eigenschaften.",

  // Advanced Keywords - Composition
  compositionTitle: "Schema-Komposition",
  compositionDescription: "Kombinieren Sie mehrere Schemas mit logischen Operatoren",
  compositionAllOfLabel: "All Of",
  compositionAllOfDescription: "Daten m√ºssen ALLE dieser Schemas erf√ºllen",
  compositionAnyOfLabel: "Any Of",
  compositionAnyOfDescription: "Daten m√ºssen MINDESTENS EINES dieser Schemas erf√ºllen",
  compositionOneOfLabel: "One Of",
  compositionOneOfDescription: "Daten m√ºssen GENAU EINES dieser Schemas erf√ºllen",
  compositionNotLabel: "Not",
  compositionNotDescription: "Daten d√ºrfen NICHT diesem Schema entsprechen",
  compositionAddSchema: "Schema hinzuf√ºgen",
  compositionSchemaNumber: "Schema {number}",
  compositionNoSchemas: "Keine {type} Schemas definiert",
  compositionAddNot: "NOT-Schema hinzuf√ºgen",
  compositionInfoTitle: "üí° Kompositions-Schl√ºsselw√∂rter",
  compositionInfoAllOf: "allOf: Kombiniert Schemas (Schnittmenge) - muss alle erf√ºllen",
  compositionInfoAnyOf: "anyOf: Alternative Schemas (Vereinigung) - muss mindestens eines erf√ºllen",
  compositionInfoOneOf: "oneOf: Exklusive Alternativen - muss genau eines erf√ºllen",
  compositionInfoNot: "not: Negation - darf nicht mit dem Schema √ºbereinstimmen",

  // Advanced Keywords - Unevaluated Properties
  unevaluatedPropsTitle: "Nicht bewertete Eigenschaften",
  unevaluatedPropsDescription: "Validierung von Eigenschaften steuern, die nicht explizit von anderen Schl√ºsselw√∂rtern behandelt werden",
  unevaluatedPropsForbid: "Nicht bewertete Eigenschaften verbieten",
  unevaluatedPropsAllow: "Nicht bewertete Eigenschaften erlauben",
  unevaluatedPropsNoAdditional: "Keine zus√§tzlichen Eigenschaften √ºber die explizit definierten hinaus erlaubt",
  unevaluatedPropsAdditionalAllowed: "Zus√§tzliche Eigenschaften sind mit optionaler Schema-Validierung erlaubt",
  unevaluatedPropsSchema: "Schema f√ºr nicht bewertete Eigenschaften",
  unevaluatedPropsSchemaHint: "Dieses Schema gilt f√ºr Eigenschaften, die nicht von properties, patternProperties oder Kompositions-Schl√ºsselw√∂rtern bewertet wurden",
  unevaluatedPropsRemove: "unevaluatedProperties-Einschr√§nkung entfernen",
  unevaluatedPropsInfoTitle: "üí° Wie es mit Komposition funktioniert",
  unevaluatedPropsInfoDescription: "In Kombination mit allOf/anyOf/oneOf verbietet unevaluatedProperties nur Eigenschaften, die von KEINEM der komponierten Schemas bewertet wurden. Dies ist m√§chtiger als additionalProperties.",
  unevaluatedPropsInfoExample: "Beispiel: Wenn Sie Eigenschaften im Hauptschema und weitere in einem allOf haben, erlaubt unevaluatedProperties: false beide Sets, verbietet aber alles andere.",
  unevaluatedPropsNoConstraint: "üìù Keine Einschr√§nkung f√ºr nicht bewertete Eigenschaften (Standardverhalten)",

  // Advanced Keywords - Unevaluated Items
  unevaluatedItemsTitle: "Nicht bewertete Elemente",
  unevaluatedItemsDescription: "Validierung von Array-Elementen steuern, die nicht explizit von anderen Schl√ºsselw√∂rtern behandelt werden",
  unevaluatedItemsForbid: "Nicht bewertete Elemente verbieten",
  unevaluatedItemsAllow: "Nicht bewertete Elemente erlauben",
  unevaluatedItemsNoAdditional: "Keine zus√§tzlichen Elemente √ºber die explizit definierten hinaus erlaubt",
  unevaluatedItemsAdditionalAllowed: "Zus√§tzliche Elemente sind mit optionaler Schema-Validierung erlaubt",
  unevaluatedItemsSchema: "Schema f√ºr nicht bewertete Elemente",
  unevaluatedItemsSchemaHint: "Dieses Schema gilt f√ºr Array-Elemente, die nicht von items, prefixItems oder contains bewertet wurden",
  unevaluatedItemsRemove: "unevaluatedItems-Einschr√§nkung entfernen",
  unevaluatedItemsInfoTitle: "üí° Wie es mit prefixItems funktioniert",
  unevaluatedItemsInfoDescription: "In Kombination mit prefixItems oder contains betrifft unevaluatedItems nur Elemente, die nicht von diesen Schl√ºsselw√∂rtern bewertet wurden. Dies erm√∂glicht pr√§zise Kontrolle √ºber Array-Validierung.",
  unevaluatedItemsInfoExample: "Beispiel: Verwenden Sie prefixItems f√ºr die ersten 3 Elemente, dann unevaluatedItems: false, um alles nach Position 2 zu verbieten.",
  unevaluatedItemsNoConstraint: "üìù Keine Einschr√§nkung f√ºr nicht bewertete Elemente (Standardverhalten)",

  // Common keywords
  remove: "Entfernen",
  add: "Hinzuf√ºgen",
};
