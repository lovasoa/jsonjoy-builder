import type { Translation } from "../translation-keys.ts";

export const ru: Translation = {
  collapse: "Свернуть",
  expand: "Развернуть",

  fieldDescriptionPlaceholder: "Опишите назначение этого поля",
  fieldDelete: "Удалить поле",
  fieldDescription: "Описание",
  fieldDescriptionTooltip: "Добавьте контекст о том, что представляет это поле",
  fieldNameLabel: "Имя поля",
  fieldNamePlaceholder: "например, имя, возраст, активен",
  fieldNameTooltip:
    "Используйте camelCase для лучшей читаемости (например, firstName)",
  fieldRequiredLabel: "Обязательное поле",
  fieldType: "Тип поля",
  fieldTypeExample: "Пример:",
  fieldTypeTooltipString: "строка: Текст",
  fieldTypeTooltipNumber: "число: Числовое значение",
  fieldTypeTooltipBoolean: "логическое: Истина/ложь",
  fieldTypeTooltipObject: "объект: Вложенный JSON",
  fieldTypeTooltipArray: "массив: Списки значений",
  fieldAddNewButton: "Добавить поле",
  fieldAddNewBadge: "Конструктор схем",
  fieldAddNewCancel: "Отмена",
  fieldAddNewConfirm: "Добавить поле",
  fieldAddNewDescription: "Создайте новое поле для вашей схемы JSON",
  fieldAddNewLabel: "Добавить новое поле",

  fieldTypeTextLabel: "Текст",
  fieldTypeTextDescription:
    "Для текстовых значений, таких как имена, описания и т.д.",
  fieldTypeNumberLabel: "Число",
  fieldTypeNumberDescription: "Для десятичных или целых чисел",
  fieldTypeBooleanLabel: "Да/Нет",
  fieldTypeBooleanDescription: "Для значений истина/ложь",
  fieldTypeObjectLabel: "Группа",
  fieldTypeObjectDescription: "Для группировки связанных полей вместе",
  fieldTypeArrayLabel: "Список",
  fieldTypeArrayDescription: "Для коллекций элементов",

  propertyDescriptionPlaceholder: "Добавить описание...",
  propertyDescriptionButton: "Добавить описание...",
  propertyRequired: "Обязательное",
  propertyOptional: "Необязательное",
  propertyDelete: "Удалить поле",

  schemaEditorTitle: "Редактор JSON схем",
  schemaEditorToggleFullscreen: "Переключить полноэкранный режим",
  schemaEditorEditModeVisual: "Визуальный",
  schemaEditorEditModeJson: "JSON",

  arrayMinimumLabel: "Минимум элементов",
  arrayMinimumPlaceholder: "Нет минимума",
  arrayMaximumLabel: "Максимум элементов",
  arrayMaximumPlaceholder: "Нет максимума",
  arrayForceUniqueItemsLabel: "Требовать уникальные элементы",
  arrayItemTypeLabel: "Тип элемента",
  arrayValidationErrorMinMax: "'minItems' не может быть больше 'maxItems'.",
  arrayValidationErrorContainsMinMax:
    "'minContains' не может быть больше 'maxContains'.",

  booleanAllowFalseLabel: "Разрешить значение ложь",
  booleanAllowTrueLabel: "Разрешить значение истина",
  booleanNeitherWarning: "Внимание: Вы должны разрешить хотя бы одно значение.",

  numberMinimumLabel: "Минимальное значение",
  numberMinimumPlaceholder: "Нет минимума",
  numberMaximumLabel: "Максимальное значение",
  numberMaximumPlaceholder: "Нет максимума",
  numberExclusiveMinimumLabel: "Исключающее минимальное",
  numberExclusiveMinimumPlaceholder: "Нет исключающего минимума",
  numberExclusiveMaximumLabel: "Исключающее максимальное",
  numberExclusiveMaximumPlaceholder: "Нет исключающего максимума",
  numberMultipleOfLabel: "Кратно",
  numberMultipleOfPlaceholder: "Любое",
  numberAllowedValuesEnumLabel: "Разрешенные значения (enum)",
  numberAllowedValuesEnumNone: "Нет ограниченных значений",
  numberAllowedValuesEnumAddLabel: "Добавить",
  numberAllowedValuesEnumAddPlaceholder: "Добавить разрешенное значение...",
  numberValidationErrorMinMax:
    "Минимальное и максимальное значения должны быть согласованы.",
  numberValidationErrorBothExclusiveAndInclusiveMin:
    "Оба поля 'exclusiveMinimum' и 'minimum' не могут быть установлены одновременно.",
  numberValidationErrorBothExclusiveAndInclusiveMax:
    "Оба поля 'exclusiveMaximum' и 'maximum' не могут быть установлены одновременно.",
  numberValidationErrorEnumOutOfRange:
    "Значения перечисления должны быть в пределах определенного диапазона.",

  objectPropertiesNone: "Нет определенных свойств",
  objectValidationErrorMinMax:
    "'minProperties' не может быть больше 'maxProperties'.",

  stringMinimumLengthLabel: "Минимальная длина",
  stringMinimumLengthPlaceholder: "Нет минимума",
  stringMaximumLengthLabel: "Максимальная длина",
  stringMaximumLengthPlaceholder: "Нет максимума",
  stringPatternLabel: "Шаблон (regex)",
  stringPatternPlaceholder: "^[a-zA-Z]+$",
  stringFormatLabel: "Формат",
  stringFormatNone: "Нет",
  stringFormatDateTime: "Дата-Время",
  stringFormatDate: "Дата",
  stringFormatTime: "Время",
  stringFormatEmail: "Email",
  stringFormatUri: "URI",
  stringFormatUuid: "UUID",
  stringFormatHostname: "Имя хоста",
  stringFormatIpv4: "Адрес IPv4",
  stringFormatIpv6: "Адрес IPv6",
  stringAllowedValuesEnumLabel: "Разрешенные значения (enum)",
  stringAllowedValuesEnumNone: "Нет ограниченных значений",
  stringAllowedValuesEnumAddPlaceholder: "Добавить разрешенное значение...",
  stringValidationErrorLengthRange:
    "'Минимальная длина' не может быть больше 'Максимальной длины'.",

  schemaTypeArray: "Список",
  schemaTypeBoolean: "Да/Нет",
  schemaTypeNumber: "Число",
  schemaTypeObject: "Объект",
  schemaTypeString: "Текст",
  schemaTypeNull: "Пусто",

  inferrerTitle: "Вывести схему JSON",
  inferrerDescription:
    "Вставьте ваш документ JSON ниже, чтобы сгенерировать из него схему.",
  inferrerCancel: "Отмена",
  inferrerGenerate: "Сгенерировать схему",
  inferrerErrorInvalidJson:
    "Неверный формат JSON. Пожалуйста, проверьте ваши данные.",

  validatorTitle: "Проверить JSON",
  validatorDescription:
    "Вставьте ваш документ JSON для проверки по текущей схеме. Проверка происходит автоматически по мере ввода.",
  validatorCurrentSchema: "Текущая схема:",
  validatorContent: "Ваш JSON:",
  validatorValid: "JSON действителен в соответствии со схемой!",
  validatorErrorInvalidSyntax: "Неверный синтаксис JSON",
  validatorErrorSchemaValidation: "Ошибка проверки схемы",
  validatorErrorCount: "Обнаружено ошибок проверки: {count}",
  validatorErrorPathRoot: "Корень",
  validatorErrorLocationLineAndColumn: "Строка {line}, столбец {column}",
  validatorErrorLocationLineOnly: "Строка {line}",

  visualizerDownloadTitle: "Скачать схему",
  visualizerDownloadFileName: "schema.json",
  visualizerSource: "Источник схемы JSON",

  visualEditorNoFieldsHint1: "Пока не определено ни одного поля",
  visualEditorNoFieldsHint2: "Добавьте ваше первое поле, чтобы начать",

  typeValidationErrorNegativeLength:
    "Значения длины не могут быть отрицательными.",
  typeValidationErrorIntValue: "Значение должно быть целым числом.",
  typeValidationErrorPositive: "Значение должно быть положительным.",

  // Advanced Keywords - Conditional Schema
  conditionalTitle: "Условная валидация (if/then/else)",
  conditionalRemoveAll: "Удалить всё",
  conditionalIfLabel: "IF (Условие)",
  conditionalAddIf: "Добавить условие IF",
  conditionalIfHint: "Когда эта схема совпадает, применить схему THEN",
  conditionalThenLabel: "THEN (Применить когда IF совпадает)",
  conditionalAddThen: "Добавить схему THEN",
  conditionalThenHint: "Эта схема применяется, когда условие IF совпадает",
  conditionalElseLabel: "ELSE (Применить когда IF не совпадает)",
  conditionalAddElse: "Добавить схему ELSE",
  conditionalElseHint: "Эта схема применяется, когда условие IF не совпадает",
  conditionalNoCondition: "Условная валидация не определена",
  conditionalNoConditionHint: "Добавьте условие IF, чтобы включить условную валидацию схемы",

  // Advanced Keywords - Prefix Items
  prefixItemsTitle: "Валидация кортежей (prefixItems)",
  prefixItemsDescription: "Определить схемы для каждой позиции в массиве",
  prefixItemsAddPosition: "Добавить позицию",
  prefixItemsPositionLabel: "Схема позиции {index}",
  prefixItemsNoPositions: "Позиции кортежа не определены",
  prefixItemsNoPositionsHint: "Добавьте позиции, чтобы определить кортеж с фиксированной схемой для каждой позиции",
  prefixItemsAllowAdditional: "Разрешить дополнительные элементы",
  prefixItemsAllowAdditionalHint: "Контролировать, разрешены ли элементы за пределами определённых позиций",
  prefixItemsAdditionalSchema: "Схема для дополнительных элементов",
  prefixItemsAdditionalSchemaHint: "Схема для элементов за пределами позиции {count}",
  prefixItemsTip: "💡 Совет: prefixItems заменяет форму массива items из Draft-07 для валидации кортежей",

  // Advanced Keywords - Dynamic References
  dynamicRefsTitle: "Динамические ссылки",
  dynamicRefsDescription: "Расширенная композиция схемы с динамическими якорями и ссылками",
  dynamicAnchorLabel: "Динамический якорь ($dynamicAnchor)",
  dynamicAnchorPlaceholder: "например, node или #meta",
  dynamicAnchorHint: "Определите динамический якорь, на который можно ссылаться в схемах. Используйте это для создания точек расширения в вашей схеме, которые можно переопределить в производных схемах.",
  dynamicRefLabel: "Динамическая ссылка ($dynamicRef)",
  dynamicRefPlaceholder: "например, #node или https://example.com/schema#meta",
  dynamicRefHint: "Ссылка на динамический якорь, определённый в этой или другой схеме. Ссылка разрешается динамически во время валидации.",
  dynamicRefsInfoTitle: "💡 Что такое динамические ссылки?",
  dynamicRefsInfoDescription: "Динамические ссылки ($dynamicRef и $dynamicAnchor) позволяют схемам ссылаться на точки привязки, которые могут быть переопределены в расширяющих схемах. Это позволяет использовать расширенные шаблоны композиции, такие как рекурсивные схемы с точками расширения.",
  dynamicRefsInfoExample: "Пример: Древовидная структура, где каждый узел может быть расширен пользовательскими свойствами при сохранении базовой структуры.",
  dynamicRefsMigrationNote: "📝 Примечание: $dynamicRef и $dynamicAnchor заменяют $recursiveRef и $recursiveAnchor из Draft 2019-09",

  // Advanced Keywords - Dependent Schemas
  dependentSchemasTitle: "Зависимые схемы",
  dependentSchemasDescription: "Определить схемы, которые применяются при наличии определённых свойств",
  dependentSchemasWhenPresent: "Когда {property} присутствует:",
  dependentSchemasAppliesWhen: "Эта схема будет применена, когда свойство \"{property}\" присутствует в объекте",
  dependentSchemasNone: "Зависимые схемы не определены",
  dependentSchemasNoneHint: "Добавьте зависимые схемы для применения дополнительной валидации при наличии определённых свойств",
  dependentSchemasAddLabel: "Добавить зависимую схему",
  dependentSchemasPropertyPlaceholder: "Имя свойства (например, credit_card)",
  dependentSchemasPropertyHint: "Введите имя свойства, наличие которого запускает дополнительную валидацию",
  dependentSchemasExampleTitle: "💡 Пример использования",
  dependentSchemasExampleText: "Когда присутствует credit_card, требовать свойства billing_address и cvv.",

  // Advanced Keywords - Composition
  compositionTitle: "Композиция схемы",
  compositionDescription: "Объединить несколько схем с помощью логических операторов",
  compositionAllOfLabel: "All Of",
  compositionAllOfDescription: "Данные должны соответствовать ВСЕМ этим схемам",
  compositionAnyOfLabel: "Any Of",
  compositionAnyOfDescription: "Данные должны соответствовать ХОТЯ БЫ ОДНОЙ из этих схем",
  compositionOneOfLabel: "One Of",
  compositionOneOfDescription: "Данные должны соответствовать ТОЧНО ОДНОЙ из этих схем",
  compositionNotLabel: "Not",
  compositionNotDescription: "Данные НЕ должны соответствовать этой схеме",
  compositionAddSchema: "Добавить схему",
  compositionSchemaNumber: "Схема {number}",
  compositionNoSchemas: "Схемы {type} не определены",
  compositionAddNot: "Добавить схему NOT",
  compositionInfoTitle: "💡 Ключевые слова композиции",
  compositionInfoAllOf: "allOf: Объединяет схемы (пересечение) - должны выполняться все",
  compositionInfoAnyOf: "anyOf: Альтернативные схемы (объединение) - должна выполняться хотя бы одна",
  compositionInfoOneOf: "oneOf: Эксклюзивные альтернативы - должна выполняться точно одна",
  compositionInfoNot: "not: Отрицание - не должна соответствовать схеме",

  // Advanced Keywords - Unevaluated Properties
  unevaluatedPropsTitle: "Неоценённые свойства",
  unevaluatedPropsDescription: "Управление валидацией свойств, не обработанных явно другими ключевыми словами",
  unevaluatedPropsForbid: "Запретить неоценённые свойства",
  unevaluatedPropsAllow: "Разрешить неоценённые свойства",
  unevaluatedPropsNoAdditional: "Дополнительные свойства не разрешены за пределами явно определённых",
  unevaluatedPropsAdditionalAllowed: "Дополнительные свойства разрешены с опциональной валидацией схемы",
  unevaluatedPropsSchema: "Схема для неоценённых свойств",
  unevaluatedPropsSchemaHint: "Эта схема применяется к свойствам, не оценённым properties, patternProperties или ключевыми словами композиции",
  unevaluatedPropsRemove: "Удалить ограничение unevaluatedProperties",
  unevaluatedPropsInfoTitle: "💡 Как это работает с композицией",
  unevaluatedPropsInfoDescription: "При объединении с allOf/anyOf/oneOf, unevaluatedProperties запрещает только свойства, которые не были оценены ЛЮБОЙ из составленных схем. Это мощнее, чем additionalProperties.",
  unevaluatedPropsInfoExample: "Пример: Если у вас есть свойства в основной схеме и ещё в allOf, unevaluatedProperties: false разрешит оба набора, но запретит всё остальное.",
  unevaluatedPropsNoConstraint: "📝 Нет ограничений на неоценённые свойства (поведение по умолчанию)",

  // Advanced Keywords - Unevaluated Items
  unevaluatedItemsTitle: "Неоценённые элементы",
  unevaluatedItemsDescription: "Управление валидацией элементов массива, не обработанных явно другими ключевыми словами",
  unevaluatedItemsForbid: "Запретить неоценённые элементы",
  unevaluatedItemsAllow: "Разрешить неоценённые элементы",
  unevaluatedItemsNoAdditional: "Дополнительные элементы не разрешены за пределами явно определённых",
  unevaluatedItemsAdditionalAllowed: "Дополнительные элементы разрешены с опциональной валидацией схемы",
  unevaluatedItemsSchema: "Схема для неоценённых элементов",
  unevaluatedItemsSchemaHint: "Эта схема применяется к элементам массива, не оценённым items, prefixItems или contains",
  unevaluatedItemsRemove: "Удалить ограничение unevaluatedItems",
  unevaluatedItemsInfoTitle: "💡 Как это работает с prefixItems",
  unevaluatedItemsInfoDescription: "При объединении с prefixItems или contains, unevaluatedItems влияет только на элементы, не оценённые этими ключевыми словами. Это позволяет точно контролировать валидацию массивов.",
  unevaluatedItemsInfoExample: "Пример: Используйте prefixItems для первых 3 элементов, затем unevaluatedItems: false, чтобы запретить всё после позиции 2.",
  unevaluatedItemsNoConstraint: "📝 Нет ограничений на неоценённые элементы (поведение по умолчанию)",

  // Common keywords
  remove: "Удалить",
  add: "Добавить",
};
