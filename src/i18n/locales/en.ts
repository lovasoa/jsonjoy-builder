import type { Translation } from "../translation-keys.ts";

export const en: Translation = {
  collapse: "Collapse",
  expand: "Expand",

  fieldDescriptionPlaceholder: "Describe the purpose of this field",
  fieldDelete: "Delete field",
  fieldDescription: "Description",
  fieldDescriptionTooltip: "Add context about what this field represents",
  fieldNameLabel: "Field Name",
  fieldNamePlaceholder: "e.g. firstName, age, isActive",
  fieldNameTooltip: "Use camelCase for better readability (e.g., firstName)",
  fieldRequiredLabel: "Required Field",
  fieldType: "Field Type",
  fieldTypeExample: "Example:",
  fieldTypeTooltipString: "string: Text",
  fieldTypeTooltipNumber: "number: Numeric",
  fieldTypeTooltipBoolean: "boolean: True/false",
  fieldTypeTooltipObject: "object: Nested JSON",
  fieldTypeTooltipArray: "array: Lists of values",
  fieldAddNewButton: "Add Field",
  fieldAddNewBadge: "Schema Builder",
  fieldAddNewCancel: "Cancel",
  fieldAddNewConfirm: "Add Field",
  fieldAddNewDescription: "Create a new field for your JSON schema",
  fieldAddNewLabel: "Add New Field",

  fieldTypeTextLabel: "Text",
  fieldTypeTextDescription: "For text values like names, descriptions, etc.",
  fieldTypeNumberLabel: "Number",
  fieldTypeNumberDescription: "For decimal or whole numbers",
  fieldTypeBooleanLabel: "Yes/No",
  fieldTypeBooleanDescription: "For true/false values",
  fieldTypeObjectLabel: "Group",
  fieldTypeObjectDescription: "For grouping related fields together",
  fieldTypeArrayLabel: "List",
  fieldTypeArrayDescription: "For collections of items",

  propertyDescriptionPlaceholder: "Add description...",
  propertyDescriptionButton: "Add description...",
  propertyRequired: "Required",
  propertyOptional: "Optional",
  propertyDelete: "Delete field",

  schemaEditorTitle: "JSON Schema Editor",
  schemaEditorToggleFullscreen: "Toggle fullscreen",
  schemaEditorEditModeVisual: "Visual",
  schemaEditorEditModeJson: "JSON",

  arrayMinimumLabel: "Minimum Items",
  arrayMinimumPlaceholder: "No minimum",
  arrayMaximumLabel: "Maximum Items",
  arrayMaximumPlaceholder: "No maximum",
  arrayForceUniqueItemsLabel: "Force unique items",
  arrayItemTypeLabel: "Item Type",
  arrayValidationErrorMinMax: "'minItems' cannot be greater than 'maxItems'.",
  arrayValidationErrorContainsMinMax:
    "'minContains' cannot be greater than 'maxContains'.",

  booleanAllowFalseLabel: "Allow false value",
  booleanAllowTrueLabel: "Allow true value",
  booleanNeitherWarning: "Warning: You must allow at least one value.",

  numberMinimumLabel: "Minimum Value",
  numberMinimumPlaceholder: "No minimum",
  numberMaximumLabel: "Maximum Value",
  numberMaximumPlaceholder: "No maximum",
  numberExclusiveMinimumLabel: "Exclusive Minimum",
  numberExclusiveMinimumPlaceholder: "No exclusive min",
  numberExclusiveMaximumLabel: "Exclusive Maximum",
  numberExclusiveMaximumPlaceholder: "No exclusive max",
  numberMultipleOfLabel: "Multiple Of",
  numberMultipleOfPlaceholder: "Any",
  numberAllowedValuesEnumLabel: "Allowed Values (enum)",
  numberAllowedValuesEnumNone: "No restricted values set",
  numberAllowedValuesEnumAddLabel: "Add",
  numberAllowedValuesEnumAddPlaceholder: "Add allowed value...",
  numberValidationErrorMinMax: "Minimum and maximum values must be consistent.",
  numberValidationErrorBothExclusiveAndInclusiveMin:
    "Both 'exclusiveMinimum' and 'minimum' cannot be set at the same time.",
  numberValidationErrorBothExclusiveAndInclusiveMax:
    "Both 'exclusiveMaximum' and 'maximum' cannot be set at the same time.",
  numberValidationErrorEnumOutOfRange:
    "Enum values must be within the defined range.",

  objectPropertiesNone: "No properties defined",
  objectValidationErrorMinMax:
    "'minProperties' cannot be greater than 'maxProperties'.",

  stringMinimumLengthLabel: "Minimum Length",
  stringMinimumLengthPlaceholder: "No minimum",
  stringMaximumLengthLabel: "Maximum Length",
  stringMaximumLengthPlaceholder: "No maximum",
  stringPatternLabel: "Pattern (regex)",
  stringPatternPlaceholder: "^[a-zA-Z]+$",
  stringFormatLabel: "Format",
  stringFormatNone: "None",
  stringFormatDateTime: "Date-Time",
  stringFormatDate: "Date",
  stringFormatTime: "Time",
  stringFormatEmail: "Email",
  stringFormatUri: "URI",
  stringFormatUuid: "UUID",
  stringFormatHostname: "Hostname",
  stringFormatIpv4: "IPv4 Address",
  stringFormatIpv6: "IPv6 Address",
  stringAllowedValuesEnumLabel: "Allowed Values (enum)",
  stringAllowedValuesEnumNone: "No restricted values set",
  stringAllowedValuesEnumAddPlaceholder: "Add allowed value...",
  stringValidationErrorLengthRange:
    "'Minimum Length' cannot be greater than 'Maximum Length'.",

  schemaTypeArray: "List",
  schemaTypeBoolean: "Yes/No",
  schemaTypeNumber: "Number",
  schemaTypeObject: "Object",
  schemaTypeString: "Text",
  schemaTypeNull: "Empty",

  inferrerTitle: "Infer JSON Schema",
  inferrerDescription:
    "Paste your JSON document below to generate a schema from it.",
  inferrerCancel: "Cancel",
  inferrerGenerate: "Generate Schema",
  inferrerErrorInvalidJson: "Invalid JSON format. Please check your input.",

  validatorTitle: "Validate JSON",
  validatorDescription:
    "Paste your JSON document to validate against the current schema. Validation occurs automatically as you type.",
  validatorCurrentSchema: "Current Schema:",
  validatorContent: "Your JSON:",
  validatorValid: "JSON is valid according to the schema!",
  validatorErrorInvalidSyntax: "Invalid JSON syntax",
  validatorErrorSchemaValidation: "Schema validation error",
  validatorErrorCount: "{count} validation errors detected",
  validatorErrorPathRoot: "Root",
  validatorErrorLocationLineAndColumn: "Line {line}, Col {column}",
  validatorErrorLocationLineOnly: "Line {line}",

  visualizerDownloadTitle: "Download Schema",
  visualizerDownloadFileName: "schema.json",
  visualizerSource: "JSON Schema Source",

  visualEditorNoFieldsHint1: "No fields defined yet",
  visualEditorNoFieldsHint2: "Add your first field to get started",

  typeValidationErrorNegativeLength: "Length values cannot be negative.",
  typeValidationErrorIntValue: "Value must be an integer.",
  typeValidationErrorPositive: "Value must be positive.",

  // Advanced Keywords - Conditional Schema
  conditionalTitle: "Conditional Validation (if/then/else)",
  conditionalRemoveAll: "Remove All",
  conditionalIfLabel: "IF (Condition)",
  conditionalAddIf: "Add IF condition",
  conditionalIfHint: "When this schema matches, apply THEN schema",
  conditionalThenLabel: "THEN (Apply when IF matches)",
  conditionalAddThen: "Add THEN schema",
  conditionalThenHint: "This schema applies when the IF condition matches",
  conditionalElseLabel: "ELSE (Apply when IF doesn't match)",
  conditionalAddElse: "Add ELSE schema",
  conditionalElseHint: "This schema applies when the IF condition doesn't match",
  conditionalNoCondition: "No conditional validation defined",
  conditionalNoConditionHint: "Add an IF condition to enable conditional schema validation",

  // Advanced Keywords - Prefix Items
  prefixItemsTitle: "Tuple Validation (prefixItems)",
  prefixItemsDescription: "Define schemas for each position in the array",
  prefixItemsAddPosition: "Add Position",
  prefixItemsPositionLabel: "Position {index} Schema",
  prefixItemsNoPositions: "No tuple positions defined",
  prefixItemsNoPositionsHint: "Add positions to define a tuple with fixed schema for each position",
  prefixItemsAllowAdditional: "Allow Additional Items",
  prefixItemsAllowAdditionalHint: "Control whether items beyond defined positions are allowed",
  prefixItemsAdditionalSchema: "Additional Items Schema",
  prefixItemsAdditionalSchemaHint: "Schema for items beyond position {count}",
  prefixItemsTip: "üí° Tip: prefixItems replaces the array form of items from Draft-07 for tuple validation",

  // Advanced Keywords - Dynamic References
  dynamicRefsTitle: "Dynamic References",
  dynamicRefsDescription: "Advanced schema composition with dynamic anchors and references",
  dynamicAnchorLabel: "Dynamic Anchor ($dynamicAnchor)",
  dynamicAnchorPlaceholder: "e.g., node or #meta",
  dynamicAnchorHint: "Define a dynamic anchor that can be referenced across schemas. Use this to create extension points in your schema that can be overridden in derived schemas.",
  dynamicRefLabel: "Dynamic Reference ($dynamicRef)",
  dynamicRefPlaceholder: "e.g., #node or https://example.com/schema#meta",
  dynamicRefHint: "Reference a dynamic anchor defined in this schema or another schema. The reference is resolved dynamically during validation.",
  dynamicRefsInfoTitle: "üí° What are Dynamic References?",
  dynamicRefsInfoDescription: "Dynamic references ($dynamicRef and $dynamicAnchor) allow schemas to reference anchor points that can be overridden in extending schemas. This enables advanced composition patterns like recursive schemas with extension points.",
  dynamicRefsInfoExample: "Example: A tree structure where each node can be extended with custom properties while maintaining the base structure.",
  dynamicRefsMigrationNote: "üìù Note: $dynamicRef and $dynamicAnchor replace $recursiveRef and $recursiveAnchor from Draft 2019-09",

  // Advanced Keywords - Dependent Schemas
  dependentSchemasTitle: "Dependent Schemas",
  dependentSchemasDescription: "Define schemas that apply when specific properties are present",
  dependentSchemasWhenPresent: "When {property} is present:",
  dependentSchemasAppliesWhen: "This schema will be applied when the property \"{property}\" is present in the object",
  dependentSchemasNone: "No dependent schemas defined",
  dependentSchemasNoneHint: "Add dependent schemas to apply additional validation when specific properties are present",
  dependentSchemasAddLabel: "Add Dependent Schema",
  dependentSchemasPropertyPlaceholder: "Property name (e.g., credit_card)",
  dependentSchemasPropertyHint: "Enter the property name whose presence triggers additional validation",
  dependentSchemasExampleTitle: "üí° Example Use Case",
  dependentSchemasExampleText: "When credit_card is present, require billing_address and cvv properties.",

  // Advanced Keywords - Composition
  compositionTitle: "Schema Composition",
  compositionDescription: "Combine multiple schemas using logical operators",
  compositionAllOfLabel: "All Of",
  compositionAllOfDescription: "Data must match ALL of these schemas",
  compositionAnyOfLabel: "Any Of",
  compositionAnyOfDescription: "Data must match AT LEAST ONE of these schemas",
  compositionOneOfLabel: "One Of",
  compositionOneOfDescription: "Data must match EXACTLY ONE of these schemas",
  compositionNotLabel: "Not",
  compositionNotDescription: "Data must NOT match this schema",
  compositionAddSchema: "Add Schema",
  compositionSchemaNumber: "Schema {number}",
  compositionNoSchemas: "No {type} schemas defined",
  compositionAddNot: "Add NOT schema",
  compositionInfoTitle: "üí° Composition Keywords",
  compositionInfoAllOf: "allOf: Combines schemas (intersection) - must satisfy all",
  compositionInfoAnyOf: "anyOf: Alternative schemas (union) - must satisfy at least one",
  compositionInfoOneOf: "oneOf: Exclusive alternatives - must satisfy exactly one",
  compositionInfoNot: "not: Negation - must not match the schema",

  // Advanced Keywords - Unevaluated Properties
  unevaluatedPropsTitle: "Unevaluated Properties",
  unevaluatedPropsDescription: "Control validation of properties not explicitly handled by other keywords",
  unevaluatedPropsForbid: "Forbid Unevaluated Properties",
  unevaluatedPropsAllow: "Allow Unevaluated Properties",
  unevaluatedPropsNoAdditional: "No additional properties allowed beyond those explicitly defined",
  unevaluatedPropsAdditionalAllowed: "Additional properties are allowed with optional schema validation",
  unevaluatedPropsSchema: "Schema for Unevaluated Properties",
  unevaluatedPropsSchemaHint: "This schema applies to properties not evaluated by properties, patternProperties, or composition keywords",
  unevaluatedPropsRemove: "Remove unevaluatedProperties constraint",
  unevaluatedPropsInfoTitle: "üí° How it works with composition",
  unevaluatedPropsInfoDescription: "When combined with allOf/anyOf/oneOf, unevaluatedProperties only forbids properties that weren't evaluated by ANY of the composed schemas. This is more powerful than additionalProperties.",
  unevaluatedPropsInfoExample: "Example: If you have properties in the main schema and more in an allOf, unevaluatedProperties: false will allow both sets but forbid anything else.",
  unevaluatedPropsNoConstraint: "üìù No constraint on unevaluated properties (default behavior)",

  // Advanced Keywords - Unevaluated Items
  unevaluatedItemsTitle: "Unevaluated Items",
  unevaluatedItemsDescription: "Control validation of array items not explicitly handled by other keywords",
  unevaluatedItemsForbid: "Forbid Unevaluated Items",
  unevaluatedItemsAllow: "Allow Unevaluated Items",
  unevaluatedItemsNoAdditional: "No additional items allowed beyond those explicitly defined",
  unevaluatedItemsAdditionalAllowed: "Additional items are allowed with optional schema validation",
  unevaluatedItemsSchema: "Schema for Unevaluated Items",
  unevaluatedItemsSchemaHint: "This schema applies to array items not evaluated by items, prefixItems, or contains keywords",
  unevaluatedItemsRemove: "Remove unevaluatedItems constraint",
  unevaluatedItemsInfoTitle: "üí° How it works with prefixItems",
  unevaluatedItemsInfoDescription: "When combined with prefixItems or contains, unevaluatedItems only affects items that weren't evaluated by those keywords. This allows precise control over array validation.",
  unevaluatedItemsInfoExample: "Example: Use prefixItems for first 3 items, then unevaluatedItems: false to forbid anything after position 2.",
  unevaluatedItemsNoConstraint: "üìù No constraint on unevaluated items (default behavior)",

  // Common keywords
  remove: "Remove",
  add: "Add",
};
