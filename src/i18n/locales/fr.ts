import type { Translation } from "../translation-keys.ts";

export const fr: Translation = {
  collapse: "R√©duire",
  expand: "√âtendre",

  fieldDescriptionPlaceholder: "D√©crivez le but de ce champ",
  fieldDelete: "Supprimer le champ",
  fieldDescription: "Description",
  fieldDescriptionTooltip: "Ajoutez du contexte sur ce que ce champ repr√©sente",
  fieldNameLabel: "Nom du champ",
  fieldNamePlaceholder: "ex. prenom, age, estActif",
  fieldNameTooltip:
    "Utilisez camelCase pour une meilleure lisibilit√© (ex. prenom)",
  fieldRequiredLabel: "Champ obligatoire",
  fieldType: "Type de champ",
  fieldTypeExample: "Exemple:",
  fieldTypeTooltipString: "cha√Æne: Texte",
  fieldTypeTooltipNumber: "nombre: Num√©rique",
  fieldTypeTooltipBoolean: "bool√©en: Vrai/faux",
  fieldTypeTooltipObject: "objet: JSON imbriqu√©",
  fieldTypeTooltipArray: "tableau: Listes de valeurs",
  fieldAddNewButton: "Ajouter un champ",
  fieldAddNewBadge: "Constructeur de sch√©ma",
  fieldAddNewCancel: "Annuler",
  fieldAddNewConfirm: "Ajouter un champ",
  fieldAddNewDescription: "Cr√©ez un nouveau champ pour votre sch√©ma JSON",
  fieldAddNewLabel: "Ajouter un nouveau champ",

  fieldTypeTextLabel: "Texte",
  fieldTypeTextDescription:
    "Pour les valeurs textuelles comme les noms, descriptions, etc.",
  fieldTypeNumberLabel: "Nombre",
  fieldTypeNumberDescription: "Pour les nombres d√©cimaux ou entiers",
  fieldTypeBooleanLabel: "Oui/Non",
  fieldTypeBooleanDescription: "Pour les valeurs vrai/faux",
  fieldTypeObjectLabel: "Groupe",
  fieldTypeObjectDescription: "Pour regrouper des champs connexes",
  fieldTypeArrayLabel: "Liste",
  fieldTypeArrayDescription: "Pour les collections d'√©l√©ments",

  propertyDescriptionPlaceholder: "Ajouter une description...",
  propertyDescriptionButton: "Ajouter une description...",
  propertyRequired: "Obligatoire",
  propertyOptional: "Facultatif",
  propertyDelete: "Supprimer le champ",

  schemaEditorTitle: "√âditeur de sch√©ma JSON",
  schemaEditorToggleFullscreen: "Basculer en plein √©cran",
  schemaEditorEditModeVisual: "Visuel",
  schemaEditorEditModeJson: "JSON",

  arrayMinimumLabel: "√âl√©ments minimum",
  arrayMinimumPlaceholder: "Pas de minimum",
  arrayMaximumLabel: "√âl√©ments maximum",
  arrayMaximumPlaceholder: "Pas de maximum",
  arrayForceUniqueItemsLabel: "Forcer les √©l√©ments uniques",
  arrayItemTypeLabel: "Type d'√©l√©ment",
  arrayValidationErrorMinMax:
    "'minItems' ne peut pas √™tre sup√©rieur √† 'maxItems'.",
  arrayValidationErrorContainsMinMax:
    "'minContains' ne peut pas √™tre sup√©rieur √† 'maxContains'.",

  booleanAllowFalseLabel: "Autoriser la valeur faux",
  booleanAllowTrueLabel: "Autoriser la valeur vrai",
  booleanNeitherWarning:
    "Avertissement: Vous devez autoriser au moins une valeur.",

  numberMinimumLabel: "Valeur minimale",
  numberMinimumPlaceholder: "Pas de minimum",
  numberMaximumLabel: "Valeur maximale",
  numberMaximumPlaceholder: "Pas de maximum",
  numberExclusiveMinimumLabel: "Minimum exclusif",
  numberExclusiveMinimumPlaceholder: "Pas de min exclusif",
  numberExclusiveMaximumLabel: "Maximum exclusif",
  numberExclusiveMaximumPlaceholder: "Pas de max exclusif",
  numberMultipleOfLabel: "Multiple de",
  numberMultipleOfPlaceholder: "Quelconque",
  numberAllowedValuesEnumLabel: "Valeurs autoris√©es (enum)",
  numberAllowedValuesEnumNone: "Aucune valeur restreinte d√©finie",
  numberAllowedValuesEnumAddLabel: "Ajouter",
  numberAllowedValuesEnumAddPlaceholder: "Ajouter une valeur autoris√©e...",
  numberValidationErrorMinMax: "Minimum et maximum doivent √™tre coh√©rents.",
  numberValidationErrorBothExclusiveAndInclusiveMin:
    "Les champs 'exclusiveMinimum' et 'minimum' ne peuvent pas √™tre d√©finis en m√™me temps.",
  numberValidationErrorBothExclusiveAndInclusiveMax:
    "Les champs 'exclusiveMaximum' et 'maximum' ne peuvent pas √™tre d√©finis en m√™me temps.",
  numberValidationErrorEnumOutOfRange:
    "Les valeurs d'√©num√©ration doivent √™tre dans la plage d√©finie.",

  objectPropertiesNone: "Aucune propri√©t√© d√©finie",
  objectValidationErrorMinMax:
    "'minProperties' ne peut pas √™tre sup√©rieur √† 'maxProperties'.",

  stringMinimumLengthLabel: "Longueur minimale",
  stringMinimumLengthPlaceholder: "Pas de minimum",
  stringMaximumLengthLabel: "Longueur maximale",
  stringMaximumLengthPlaceholder: "Pas de maximum",
  stringPatternLabel: "Motif (regex)",
  stringPatternPlaceholder: "^[a-zA-Z]+$",
  stringFormatLabel: "Format",
  stringFormatNone: "Aucun",
  stringFormatDateTime: "Date-Heure",
  stringFormatDate: "Date",
  stringFormatTime: "Heure",
  stringFormatEmail: "Email",
  stringFormatUri: "URI",
  stringFormatUuid: "UUID",
  stringFormatHostname: "Nom d'h√¥te",
  stringFormatIpv4: "Adresse IPv4",
  stringFormatIpv6: "Adresse IPv6",
  stringAllowedValuesEnumLabel: "Valeurs autoris√©es (enum)",
  stringAllowedValuesEnumNone: "Aucune valeur restreinte d√©finie",
  stringAllowedValuesEnumAddPlaceholder: "Ajouter une valeur autoris√©e...",
  stringValidationErrorLengthRange:
    "'Longueur minimale' ne peut pas √™tre sup√©rieure √† 'Longueur maximale'.",

  schemaTypeArray: "Liste",
  schemaTypeBoolean: "Oui/Non",
  schemaTypeNumber: "Nombre",
  schemaTypeObject: "Objet",
  schemaTypeString: "Texte",
  schemaTypeNull: "Vide",

  inferrerTitle: "D√©duire le sch√©ma JSON",
  inferrerDescription:
    "Collez votre document JSON ci-dessous pour en g√©n√©rer un sch√©ma.",
  inferrerCancel: "Annuler",
  inferrerGenerate: "G√©n√©rer le sch√©ma",
  inferrerErrorInvalidJson:
    "Format JSON invalide. Veuillez v√©rifier votre saisie.",

  validatorTitle: "Valider le JSON",
  validatorDescription:
    "Collez votre document JSON pour le valider par rapport au sch√©ma actuel. La validation se produit automatiquement pendant que vous tapez.",
  validatorCurrentSchema: "Sch√©ma actuel:",
  validatorContent: "Votre JSON:",
  validatorValid: "Le JSON est valide selon le sch√©ma!",
  validatorErrorInvalidSyntax: "Syntaxe JSON invalide",
  validatorErrorSchemaValidation: "Erreur de validation du sch√©ma",
  validatorErrorCount: "{count} erreurs de validation d√©tect√©es",
  validatorErrorPathRoot: "√âl√©ment racine",
  validatorErrorLocationLineAndColumn: "Ligne {line}, Col {column}",
  validatorErrorLocationLineOnly: "Ligne {line}",

  visualizerDownloadTitle: "T√©l√©charger le sch√©ma",
  visualizerDownloadFileName: "schema.json",
  visualizerSource: "Source du sch√©ma JSON",

  visualEditorNoFieldsHint1: "Aucun champ d√©fini pour le moment",
  visualEditorNoFieldsHint2: "Ajoutez votre premier champ pour commencer",

  typeValidationErrorNegativeLength:
    "Les valeurs de longueur ne peuvent pas √™tre n√©gatives.",
  typeValidationErrorIntValue: "La valeur doit √™tre un nombre entier.",
  typeValidationErrorPositive: "La valeur doit √™tre positive.",

  // Advanced Keywords - Conditional Schema
  conditionalTitle: "Validation conditionnelle (if/then/else)",
  conditionalRemoveAll: "Tout supprimer",
  conditionalIfLabel: "IF (Condition)",
  conditionalAddIf: "Ajouter condition IF",
  conditionalIfHint: "Lorsque ce sch√©ma correspond, appliquer le sch√©ma THEN",
  conditionalThenLabel: "THEN (Appliquer quand IF correspond)",
  conditionalAddThen: "Ajouter sch√©ma THEN",
  conditionalThenHint: "Ce sch√©ma s'applique lorsque la condition IF correspond",
  conditionalElseLabel: "ELSE (Appliquer quand IF ne correspond pas)",
  conditionalAddElse: "Ajouter sch√©ma ELSE",
  conditionalElseHint: "Ce sch√©ma s'applique lorsque la condition IF ne correspond pas",
  conditionalNoCondition: "Aucune validation conditionnelle d√©finie",
  conditionalNoConditionHint: "Ajoutez une condition IF pour activer la validation conditionnelle du sch√©ma",

  // Advanced Keywords - Prefix Items
  prefixItemsTitle: "Validation de tuple (prefixItems)",
  prefixItemsDescription: "D√©finir des sch√©mas pour chaque position dans le tableau",
  prefixItemsAddPosition: "Ajouter position",
  prefixItemsPositionLabel: "Sch√©ma de position {index}",
  prefixItemsNoPositions: "Aucune position de tuple d√©finie",
  prefixItemsNoPositionsHint: "Ajoutez des positions pour d√©finir un tuple avec un sch√©ma fixe pour chaque position",
  prefixItemsAllowAdditional: "Autoriser des √©l√©ments suppl√©mentaires",
  prefixItemsAllowAdditionalHint: "Contr√¥ler si les √©l√©ments au-del√† des positions d√©finies sont autoris√©s",
  prefixItemsAdditionalSchema: "Sch√©ma pour √©l√©ments suppl√©mentaires",
  prefixItemsAdditionalSchemaHint: "Sch√©ma pour les √©l√©ments au-del√† de la position {count}",
  prefixItemsTip: "üí° Astuce: prefixItems remplace la forme tableau de items de Draft-07 pour la validation de tuple",

  // Advanced Keywords - Dynamic References
  dynamicRefsTitle: "R√©f√©rences dynamiques",
  dynamicRefsDescription: "Composition de sch√©ma avanc√©e avec ancres et r√©f√©rences dynamiques",
  dynamicAnchorLabel: "Ancre dynamique ($dynamicAnchor)",
  dynamicAnchorPlaceholder: "ex. node ou #meta",
  dynamicAnchorHint: "D√©finissez une ancre dynamique qui peut √™tre r√©f√©renc√©e entre les sch√©mas. Utilisez ceci pour cr√©er des points d'extension dans votre sch√©ma qui peuvent √™tre remplac√©s dans les sch√©mas d√©riv√©s.",
  dynamicRefLabel: "R√©f√©rence dynamique ($dynamicRef)",
  dynamicRefPlaceholder: "ex. #node ou https://example.com/schema#meta",
  dynamicRefHint: "R√©f√©rencez une ancre dynamique d√©finie dans ce sch√©ma ou un autre. La r√©f√©rence est r√©solue dynamiquement pendant la validation.",
  dynamicRefsInfoTitle: "üí° Que sont les r√©f√©rences dynamiques?",
  dynamicRefsInfoDescription: "Les r√©f√©rences dynamiques ($dynamicRef et $dynamicAnchor) permettent aux sch√©mas de r√©f√©rencer des points d'ancrage qui peuvent √™tre remplac√©s dans les sch√©mas √©tendus. Cela permet des motifs de composition avanc√©s comme des sch√©mas r√©cursifs avec des points d'extension.",
  dynamicRefsInfoExample: "Exemple: Une structure arborescente o√π chaque n≈ìud peut √™tre √©tendu avec des propri√©t√©s personnalis√©es tout en maintenant la structure de base.",
  dynamicRefsMigrationNote: "üìù Note: $dynamicRef et $dynamicAnchor remplacent $recursiveRef et $recursiveAnchor de Draft 2019-09",

  // Advanced Keywords - Dependent Schemas
  dependentSchemasTitle: "Sch√©mas d√©pendants",
  dependentSchemasDescription: "D√©finir des sch√©mas qui s'appliquent lorsque des propri√©t√©s sp√©cifiques sont pr√©sentes",
  dependentSchemasWhenPresent: "Lorsque {property} est pr√©sent:",
  dependentSchemasAppliesWhen: "Ce sch√©ma sera appliqu√© lorsque la propri√©t√© \"{property}\" est pr√©sente dans l'objet",
  dependentSchemasNone: "Aucun sch√©ma d√©pendant d√©fini",
  dependentSchemasNoneHint: "Ajoutez des sch√©mas d√©pendants pour appliquer une validation suppl√©mentaire lorsque des propri√©t√©s sp√©cifiques sont pr√©sentes",
  dependentSchemasAddLabel: "Ajouter sch√©ma d√©pendant",
  dependentSchemasPropertyPlaceholder: "Nom de propri√©t√© (ex. credit_card)",
  dependentSchemasPropertyHint: "Entrez le nom de la propri√©t√© dont la pr√©sence d√©clenche une validation suppl√©mentaire",
  dependentSchemasExampleTitle: "üí° Exemple d'utilisation",
  dependentSchemasExampleText: "Lorsque credit_card est pr√©sent, exiger les propri√©t√©s billing_address et cvv.",

  // Advanced Keywords - Composition
  compositionTitle: "Composition de sch√©ma",
  compositionDescription: "Combiner plusieurs sch√©mas √† l'aide d'op√©rateurs logiques",
  compositionAllOfLabel: "All Of",
  compositionAllOfDescription: "Les donn√©es doivent correspondre √† TOUS ces sch√©mas",
  compositionAnyOfLabel: "Any Of",
  compositionAnyOfDescription: "Les donn√©es doivent correspondre √† AU MOINS UN de ces sch√©mas",
  compositionOneOfLabel: "One Of",
  compositionOneOfDescription: "Les donn√©es doivent correspondre √† EXACTEMENT UN de ces sch√©mas",
  compositionNotLabel: "Not",
  compositionNotDescription: "Les donn√©es NE doivent PAS correspondre √† ce sch√©ma",
  compositionAddSchema: "Ajouter sch√©ma",
  compositionSchemaNumber: "Sch√©ma {number}",
  compositionNoSchemas: "Aucun sch√©ma {type} d√©fini",
  compositionAddNot: "Ajouter sch√©ma NOT",
  compositionInfoTitle: "üí° Mots-cl√©s de composition",
  compositionInfoAllOf: "allOf: Combine les sch√©mas (intersection) - doit satisfaire tous",
  compositionInfoAnyOf: "anyOf: Sch√©mas alternatifs (union) - doit satisfaire au moins un",
  compositionInfoOneOf: "oneOf: Alternatives exclusives - doit satisfaire exactement un",
  compositionInfoNot: "not: N√©gation - ne doit pas correspondre au sch√©ma",

  // Advanced Keywords - Unevaluated Properties
  unevaluatedPropsTitle: "Propri√©t√©s non √©valu√©es",
  unevaluatedPropsDescription: "Contr√¥ler la validation des propri√©t√©s non explicitement trait√©es par d'autres mots-cl√©s",
  unevaluatedPropsForbid: "Interdire les propri√©t√©s non √©valu√©es",
  unevaluatedPropsAllow: "Autoriser les propri√©t√©s non √©valu√©es",
  unevaluatedPropsNoAdditional: "Aucune propri√©t√© suppl√©mentaire autoris√©e au-del√† de celles explicitement d√©finies",
  unevaluatedPropsAdditionalAllowed: "Les propri√©t√©s suppl√©mentaires sont autoris√©es avec validation de sch√©ma optionnelle",
  unevaluatedPropsSchema: "Sch√©ma pour propri√©t√©s non √©valu√©es",
  unevaluatedPropsSchemaHint: "Ce sch√©ma s'applique aux propri√©t√©s non √©valu√©es par properties, patternProperties ou les mots-cl√©s de composition",
  unevaluatedPropsRemove: "Supprimer la contrainte unevaluatedProperties",
  unevaluatedPropsInfoTitle: "üí° Comment cela fonctionne avec la composition",
  unevaluatedPropsInfoDescription: "Lorsqu'il est combin√© avec allOf/anyOf/oneOf, unevaluatedProperties n'interdit que les propri√©t√©s qui n'ont √©t√© √©valu√©es par AUCUN des sch√©mas compos√©s. C'est plus puissant que additionalProperties.",
  unevaluatedPropsInfoExample: "Exemple: Si vous avez des propri√©t√©s dans le sch√©ma principal et d'autres dans un allOf, unevaluatedProperties: false autorisera les deux ensembles mais interdira tout le reste.",
  unevaluatedPropsNoConstraint: "üìù Aucune contrainte sur les propri√©t√©s non √©valu√©es (comportement par d√©faut)",

  // Advanced Keywords - Unevaluated Items
  unevaluatedItemsTitle: "√âl√©ments non √©valu√©s",
  unevaluatedItemsDescription: "Contr√¥ler la validation des √©l√©ments de tableau non explicitement trait√©s par d'autres mots-cl√©s",
  unevaluatedItemsForbid: "Interdire les √©l√©ments non √©valu√©s",
  unevaluatedItemsAllow: "Autoriser les √©l√©ments non √©valu√©s",
  unevaluatedItemsNoAdditional: "Aucun √©l√©ment suppl√©mentaire autoris√© au-del√† de ceux explicitement d√©finis",
  unevaluatedItemsAdditionalAllowed: "Les √©l√©ments suppl√©mentaires sont autoris√©s avec validation de sch√©ma optionnelle",
  unevaluatedItemsSchema: "Sch√©ma pour √©l√©ments non √©valu√©s",
  unevaluatedItemsSchemaHint: "Ce sch√©ma s'applique aux √©l√©ments de tableau non √©valu√©s par items, prefixItems ou contains",
  unevaluatedItemsRemove: "Supprimer la contrainte unevaluatedItems",
  unevaluatedItemsInfoTitle: "üí° Comment cela fonctionne avec prefixItems",
  unevaluatedItemsInfoDescription: "Lorsqu'il est combin√© avec prefixItems ou contains, unevaluatedItems n'affecte que les √©l√©ments qui n'ont pas √©t√© √©valu√©s par ces mots-cl√©s. Cela permet un contr√¥le pr√©cis de la validation des tableaux.",
  unevaluatedItemsInfoExample: "Exemple: Utilisez prefixItems pour les 3 premiers √©l√©ments, puis unevaluatedItems: false pour interdire tout apr√®s la position 2.",
  unevaluatedItemsNoConstraint: "üìù Aucune contrainte sur les √©l√©ments non √©valu√©s (comportement par d√©faut)",

  // Common keywords
  remove: "Supprimer",
  add: "Ajouter",
};
